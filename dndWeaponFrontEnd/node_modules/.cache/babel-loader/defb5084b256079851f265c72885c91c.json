{"ast":null,"code":"import { ValidationMetadata } from '../../metadata/ValidationMetadata';\nimport { getMetadataStorage } from '../../metadata/MetadataStorage';\nimport { ValidationTypes } from '../../validation/ValidationTypes';\nimport { ConstraintMetadata } from '../../metadata/ConstraintMetadata';\n/**\n * Registers custom validator class.\n */\nexport function ValidatorConstraint(options) {\n  return function (target) {\n    var isAsync = options && options.async;\n    var name = options && options.name ? options.name : '';\n    if (!name) {\n      name = target.name;\n      if (!name)\n        // generate name if it was not given\n        name = name.replace(/\\.?([A-Z]+)/g, function (x, y) {\n          return '_' + y.toLowerCase();\n        }).replace(/^_/, '');\n    }\n    var metadata = new ConstraintMetadata(target, name, isAsync);\n    getMetadataStorage().addConstraintMetadata(metadata);\n  };\n}\nexport function Validate(constraintClass, constraintsOrValidationOptions, maybeValidationOptions) {\n  return function (object, propertyName) {\n    var args = {\n      type: ValidationTypes.CUSTOM_VALIDATION,\n      target: object.constructor,\n      propertyName: propertyName,\n      constraintCls: constraintClass,\n      constraints: Array.isArray(constraintsOrValidationOptions) ? constraintsOrValidationOptions : undefined,\n      validationOptions: !Array.isArray(constraintsOrValidationOptions) ? constraintsOrValidationOptions : maybeValidationOptions\n    };\n    getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n  };\n}","map":{"version":3,"mappings":"AAEA,SAASA,kBAAkB,QAAQ,mCAAmC;AACtE,SAASC,kBAAkB,QAAQ,gCAAgC;AACnE,SAASC,eAAe,QAAQ,kCAAkC;AAClE,SAASC,kBAAkB,QAAQ,mCAAmC;AAEtE;;;AAGA,OAAM,SAAUC,mBAAmBA,CAACC,OAA4C;EAC9E,OAAO,UAAUC,MAAgB;IAC/B,IAAMC,OAAO,GAAGF,OAAO,IAAIA,OAAO,CAACG,KAAK;IACxC,IAAIC,IAAI,GAAGJ,OAAO,IAAIA,OAAO,CAACI,IAAI,GAAGJ,OAAO,CAACI,IAAI,GAAG,EAAE;IACtD,IAAI,CAACA,IAAI,EAAE;MACTA,IAAI,GAAIH,MAAc,CAACG,IAAI;MAC3B,IAAI,CAACA,IAAI;QACP;QACAA,IAAI,GAAGA,IAAI,CAACC,OAAO,CAAC,cAAc,EAAE,UAACC,CAAC,EAAEC,CAAC;UAAK,UAAG,GAAIA,CAAY,CAACC,WAAW,EAAE;QAAjC,CAAiC,CAAC,CAACH,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;;IAEtG,IAAMI,QAAQ,GAAG,IAAIX,kBAAkB,CAACG,MAAM,EAAEG,IAAI,EAAEF,OAAO,CAAC;IAC9DN,kBAAkB,EAAE,CAACc,qBAAqB,CAACD,QAAQ,CAAC;EACtD,CAAC;AACH;AAYA,OAAM,SAAUE,QAAQA,CACtBC,eAAyB,EACzBC,8BAA0D,EAC1DC,sBAA0C;EAE1C,OAAO,UAAUC,MAAc,EAAEC,YAAoB;IACnD,IAAMC,IAAI,GAA2B;MACnCC,IAAI,EAAErB,eAAe,CAACsB,iBAAiB;MACvClB,MAAM,EAAEc,MAAM,CAACK,WAAW;MAC1BJ,YAAY,EAAEA,YAAY;MAC1BK,aAAa,EAAET,eAAe;MAC9BU,WAAW,EAAEC,KAAK,CAACC,OAAO,CAACX,8BAA8B,CAAC,GAAGA,8BAA8B,GAAGY,SAAS;MACvGC,iBAAiB,EAAE,CAACH,KAAK,CAACC,OAAO,CAACX,8BAA8B,CAAC,GAC7DA,8BAA8B,GAC9BC;KACL;IACDlB,kBAAkB,EAAE,CAAC+B,qBAAqB,CAAC,IAAIhC,kBAAkB,CAACsB,IAAI,CAAC,CAAC;EAC1E,CAAC;AACH","names":["ValidationMetadata","getMetadataStorage","ValidationTypes","ConstraintMetadata","ValidatorConstraint","options","target","isAsync","async","name","replace","x","y","toLowerCase","metadata","addConstraintMetadata","Validate","constraintClass","constraintsOrValidationOptions","maybeValidationOptions","object","propertyName","args","type","CUSTOM_VALIDATION","constructor","constraintCls","constraints","Array","isArray","undefined","validationOptions","addValidationMetadata"],"sourceRoot":"","sources":["../../../../src/decorator/common/Validate.ts"],"sourcesContent":["import { ValidationOptions } from '../ValidationOptions';\nimport { ValidationMetadataArgs } from '../../metadata/ValidationMetadataArgs';\nimport { ValidationMetadata } from '../../metadata/ValidationMetadata';\nimport { getMetadataStorage } from '../../metadata/MetadataStorage';\nimport { ValidationTypes } from '../../validation/ValidationTypes';\nimport { ConstraintMetadata } from '../../metadata/ConstraintMetadata';\n\n/**\n * Registers custom validator class.\n */\nexport function ValidatorConstraint(options?: { name?: string; async?: boolean }) {\n  return function (target: Function): void {\n    const isAsync = options && options.async;\n    let name = options && options.name ? options.name : '';\n    if (!name) {\n      name = (target as any).name;\n      if (!name)\n        // generate name if it was not given\n        name = name.replace(/\\.?([A-Z]+)/g, (x, y) => '_' + (y as string).toLowerCase()).replace(/^_/, '');\n    }\n    const metadata = new ConstraintMetadata(target, name, isAsync);\n    getMetadataStorage().addConstraintMetadata(metadata);\n  };\n}\n\n/**\n * Performs validation based on the given custom validation class.\n * Validation class must be decorated with ValidatorConstraint decorator.\n */\nexport function Validate(constraintClass: Function, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(\n  constraintClass: Function,\n  constraints?: any[],\n  validationOptions?: ValidationOptions\n): PropertyDecorator;\nexport function Validate(\n  constraintClass: Function,\n  constraintsOrValidationOptions?: any[] | ValidationOptions,\n  maybeValidationOptions?: ValidationOptions\n): PropertyDecorator {\n  return function (object: object, propertyName: string): void {\n    const args: ValidationMetadataArgs = {\n      type: ValidationTypes.CUSTOM_VALIDATION,\n      target: object.constructor,\n      propertyName: propertyName,\n      constraintCls: constraintClass,\n      constraints: Array.isArray(constraintsOrValidationOptions) ? constraintsOrValidationOptions : undefined,\n      validationOptions: !Array.isArray(constraintsOrValidationOptions)\n        ? constraintsOrValidationOptions\n        : maybeValidationOptions,\n    };\n    getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n  };\n}\n"]},"metadata":{},"sourceType":"module"}