{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { ValidationError } from './ValidationError';\nimport { ValidationTypes } from './ValidationTypes';\nimport { ValidationUtils } from './ValidationUtils';\nimport { isPromise, convertToArray } from '../utils';\nimport { getMetadataStorage } from '../metadata/MetadataStorage';\n/**\n * Executes validation over given object.\n */\nvar ValidationExecutor = /** @class */function () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function ValidationExecutor(validator, validatorOptions) {\n    this.validator = validator;\n    this.validatorOptions = validatorOptions;\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n    this.awaitingPromises = [];\n    this.ignoreAsyncValidations = false;\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n    this.metadataStorage = getMetadataStorage();\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  ValidationExecutor.prototype.execute = function (object, targetSchema, validationErrors) {\n    var _this = this;\n    var _a, _b;\n    /**\n     * If there is no metadata registered it means possibly the dependencies are not flatterned and\n     * more than one instance is used.\n     *\n     * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n     */\n    if (!this.metadataStorage.hasValidationMetaData && ((_a = this.validatorOptions) === null || _a === void 0 ? void 0 : _a.enableDebugMessages) === true) {\n      console.warn(\"No validation metadata found. No validation will be  performed. There are multiple possible reasons:\\n\" + \"  - There may be multiple class-validator versions installed. You will need to flatten your dependencies to fix the issue.\\n\" + \"  - This validation runs before any file with validation decorator was parsed by NodeJS.\");\n    }\n    var groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n    var strictGroups = this.validatorOptions && this.validatorOptions.strictGroups || false;\n    var always = this.validatorOptions && this.validatorOptions.always || false;\n    /** Forbid unknown values are turned on by default and any other value than false will enable it. */\n    var forbidUnknownValues = ((_b = this.validatorOptions) === null || _b === void 0 ? void 0 : _b.forbidUnknownValues) === undefined || this.validatorOptions.forbidUnknownValues !== false;\n    var targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, always, strictGroups, groups);\n    var groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n    if (this.validatorOptions && forbidUnknownValues && !targetMetadatas.length) {\n      var validationError = new ValidationError();\n      if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.target === undefined || this.validatorOptions.validationError.target === true) validationError.target = object;\n      validationError.value = undefined;\n      validationError.property = undefined;\n      validationError.children = [];\n      validationError.constraints = {\n        unknownValue: 'an unknown value was passed to the validate function'\n      };\n      validationErrors.push(validationError);\n      return;\n    }\n    if (this.validatorOptions && this.validatorOptions.whitelist) this.whitelist(object, groupedMetadatas, validationErrors);\n    // General validation\n    Object.keys(groupedMetadatas).forEach(function (propertyName) {\n      var value = object[propertyName];\n      var definedMetadatas = groupedMetadatas[propertyName].filter(function (metadata) {\n        return metadata.type === ValidationTypes.IS_DEFINED;\n      });\n      var metadatas = groupedMetadatas[propertyName].filter(function (metadata) {\n        return metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST;\n      });\n      if (value instanceof Promise && metadatas.find(function (metadata) {\n        return metadata.type === ValidationTypes.PROMISE_VALIDATION;\n      })) {\n        _this.awaitingPromises.push(value.then(function (resolvedValue) {\n          _this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n        }));\n      } else {\n        _this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n      }\n    });\n  };\n  ValidationExecutor.prototype.whitelist = function (object, groupedMetadatas, validationErrors) {\n    var _this = this;\n    var notAllowedProperties = [];\n    Object.keys(object).forEach(function (propertyName) {\n      // does this property have no metadata?\n      if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0) notAllowedProperties.push(propertyName);\n    });\n    if (notAllowedProperties.length > 0) {\n      if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n        // throw errors\n        notAllowedProperties.forEach(function (property) {\n          var _a;\n          var validationError = _this.generateValidationError(object, object[property], property);\n          validationError.constraints = (_a = {}, _a[ValidationTypes.WHITELIST] = \"property \".concat(property, \" should not exist\"), _a);\n          validationError.children = undefined;\n          validationErrors.push(validationError);\n        });\n      } else {\n        // strip non allowed properties\n        notAllowedProperties.forEach(function (property) {\n          return delete object[property];\n        });\n      }\n    }\n  };\n  ValidationExecutor.prototype.stripEmptyErrors = function (errors) {\n    var _this = this;\n    return errors.filter(function (error) {\n      if (error.children) {\n        error.children = _this.stripEmptyErrors(error.children);\n      }\n      if (Object.keys(error.constraints).length === 0) {\n        if (error.children.length === 0) {\n          return false;\n        } else {\n          delete error.constraints;\n        }\n      }\n      return true;\n    });\n  };\n  // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n  ValidationExecutor.prototype.performValidations = function (object, value, propertyName, definedMetadatas, metadatas, validationErrors) {\n    var customValidationMetadatas = metadatas.filter(function (metadata) {\n      return metadata.type === ValidationTypes.CUSTOM_VALIDATION;\n    });\n    var nestedValidationMetadatas = metadatas.filter(function (metadata) {\n      return metadata.type === ValidationTypes.NESTED_VALIDATION;\n    });\n    var conditionalValidationMetadatas = metadatas.filter(function (metadata) {\n      return metadata.type === ValidationTypes.CONDITIONAL_VALIDATION;\n    });\n    var validationError = this.generateValidationError(object, value, propertyName);\n    validationErrors.push(validationError);\n    var canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n    if (!canValidate) {\n      return;\n    }\n    // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n    this.customValidations(object, value, definedMetadatas, validationError);\n    this.mapContexts(object, value, definedMetadatas, validationError);\n    if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n      return;\n    }\n    if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n      return;\n    }\n    if ((value === null || value === undefined) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {\n      return;\n    }\n    this.customValidations(object, value, customValidationMetadatas, validationError);\n    this.nestedValidations(value, nestedValidationMetadatas, validationError);\n    this.mapContexts(object, value, metadatas, validationError);\n    this.mapContexts(object, value, customValidationMetadatas, validationError);\n  };\n  ValidationExecutor.prototype.generateValidationError = function (object, value, propertyName) {\n    var validationError = new ValidationError();\n    if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.target === undefined || this.validatorOptions.validationError.target === true) validationError.target = object;\n    if (!this.validatorOptions || !this.validatorOptions.validationError || this.validatorOptions.validationError.value === undefined || this.validatorOptions.validationError.value === true) validationError.value = value;\n    validationError.property = propertyName;\n    validationError.children = [];\n    validationError.constraints = {};\n    return validationError;\n  };\n  ValidationExecutor.prototype.conditionalValidations = function (object, value, metadatas) {\n    return metadatas.map(function (metadata) {\n      return metadata.constraints[0](object, value);\n    }).reduce(function (resultA, resultB) {\n      return resultA && resultB;\n    }, true);\n  };\n  ValidationExecutor.prototype.customValidations = function (object, value, metadatas, error) {\n    var _this = this;\n    metadatas.forEach(function (metadata) {\n      _this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls).forEach(function (customConstraintMetadata) {\n        if (customConstraintMetadata.async && _this.ignoreAsyncValidations) return;\n        if (_this.validatorOptions && _this.validatorOptions.stopAtFirstError && Object.keys(error.constraints || {}).length > 0) return;\n        var validationArguments = {\n          targetName: object.constructor ? object.constructor.name : undefined,\n          property: metadata.propertyName,\n          object: object,\n          value: value,\n          constraints: metadata.constraints\n        };\n        if (!metadata.each || !(Array.isArray(value) || value instanceof Set || value instanceof Map)) {\n          var validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n          if (isPromise(validatedValue)) {\n            var promise = validatedValue.then(function (isValid) {\n              if (!isValid) {\n                var _a = __read(_this.createValidationError(object, value, metadata, customConstraintMetadata), 2),\n                  type = _a[0],\n                  message = _a[1];\n                error.constraints[type] = message;\n                if (metadata.context) {\n                  if (!error.contexts) {\n                    error.contexts = {};\n                  }\n                  error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);\n                }\n              }\n            });\n            _this.awaitingPromises.push(promise);\n          } else {\n            if (!validatedValue) {\n              var _a = __read(_this.createValidationError(object, value, metadata, customConstraintMetadata), 2),\n                type = _a[0],\n                message = _a[1];\n              error.constraints[type] = message;\n            }\n          }\n          return;\n        }\n        // convert set and map into array\n        var arrayValue = convertToArray(value);\n        // Validation needs to be applied to each array item\n        var validatedSubValues = arrayValue.map(function (subValue) {\n          return customConstraintMetadata.instance.validate(subValue, validationArguments);\n        });\n        var validationIsAsync = validatedSubValues.some(function (validatedSubValue) {\n          return isPromise(validatedSubValue);\n        });\n        if (validationIsAsync) {\n          // Wrap plain values (if any) in promises, so that all are async\n          var asyncValidatedSubValues = validatedSubValues.map(function (validatedSubValue) {\n            return isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue);\n          });\n          var asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues).then(function (flatValidatedValues) {\n            var validationResult = flatValidatedValues.every(function (isValid) {\n              return isValid;\n            });\n            if (!validationResult) {\n              var _a = __read(_this.createValidationError(object, value, metadata, customConstraintMetadata), 2),\n                type = _a[0],\n                message = _a[1];\n              error.constraints[type] = message;\n              if (metadata.context) {\n                if (!error.contexts) {\n                  error.contexts = {};\n                }\n                error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);\n              }\n            }\n          });\n          _this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n          return;\n        }\n        var validationResult = validatedSubValues.every(function (isValid) {\n          return isValid;\n        });\n        if (!validationResult) {\n          var _b = __read(_this.createValidationError(object, value, metadata, customConstraintMetadata), 2),\n            type = _b[0],\n            message = _b[1];\n          error.constraints[type] = message;\n        }\n      });\n    });\n  };\n  ValidationExecutor.prototype.nestedValidations = function (value, metadatas, error) {\n    var _this = this;\n    if (value === void 0) {\n      return;\n    }\n    metadatas.forEach(function (metadata) {\n      if (metadata.type !== ValidationTypes.NESTED_VALIDATION && metadata.type !== ValidationTypes.PROMISE_VALIDATION) {\n        return;\n      } else if (_this.validatorOptions && _this.validatorOptions.stopAtFirstError && Object.keys(error.constraints || {}).length > 0) {\n        return;\n      }\n      if (Array.isArray(value) || value instanceof Set || value instanceof Map) {\n        // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n        var arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n        arrayLikeValue.forEach(function (subValue, index) {\n          _this.performValidations(value, subValue, index.toString(), [], metadatas, error.children);\n        });\n      } else if (value instanceof Object) {\n        var targetSchema = typeof metadata.target === 'string' ? metadata.target : metadata.target.name;\n        _this.execute(value, targetSchema, error.children);\n      } else {\n        var _a = __read(_this.createValidationError(metadata.target, value, metadata), 2),\n          type = _a[0],\n          message = _a[1];\n        error.constraints[type] = message;\n      }\n    });\n  };\n  ValidationExecutor.prototype.mapContexts = function (object, value, metadatas, error) {\n    var _this = this;\n    return metadatas.forEach(function (metadata) {\n      if (metadata.context) {\n        var customConstraint = void 0;\n        if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {\n          var customConstraints = _this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);\n          customConstraint = customConstraints[0];\n        }\n        var type = _this.getConstraintType(metadata, customConstraint);\n        if (error.constraints[type]) {\n          if (!error.contexts) {\n            error.contexts = {};\n          }\n          error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);\n        }\n      }\n    });\n  };\n  ValidationExecutor.prototype.createValidationError = function (object, value, metadata, customValidatorMetadata) {\n    var targetName = object.constructor ? object.constructor.name : undefined;\n    var type = this.getConstraintType(metadata, customValidatorMetadata);\n    var validationArguments = {\n      targetName: targetName,\n      property: metadata.propertyName,\n      object: object,\n      value: value,\n      constraints: metadata.constraints\n    };\n    var message = metadata.message || '';\n    if (!metadata.message && (!this.validatorOptions || this.validatorOptions && !this.validatorOptions.dismissDefaultMessages)) {\n      if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n        message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n      }\n    }\n    var messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n    return [type, messageString];\n  };\n  ValidationExecutor.prototype.getConstraintType = function (metadata, customValidatorMetadata) {\n    var type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n    return type;\n  };\n  return ValidationExecutor;\n}();\nexport { ValidationExecutor };","map":{"version":3,"mappings":"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","names":["ValidationError","ValidationTypes","ValidationUtils","isPromise","convertToArray","getMetadataStorage","validator","validatorOptions","ValidationExecutor","object","targetSchema","validationErrors","metadataStorage","hasValidationMetaData","enableDebugMessages","console","warn","groups","undefined","strictGroups","always","forbidUnknownValues","targetMetadatas","getTargetValidationMetadatas","constructor","groupedMetadatas","groupByPropertyName","length","validationError","target","value","property","children","constraints","unknownValue","push","whitelist","Object","keys","forEach","propertyName","definedMetadatas","filter","type","IS_DEFINED","metadatas","metadata","WHITELIST","Promise","find","PROMISE_VALIDATION","_this","awaitingPromises","then","performValidations","resolvedValue","notAllowedProperties","forbidNonWhitelisted","generateValidationError","_a","errors","error","stripEmptyErrors","customValidationMetadatas","CUSTOM_VALIDATION","nestedValidationMetadatas","NESTED_VALIDATION","conditionalValidationMetadatas","CONDITIONAL_VALIDATION","canValidate","conditionalValidations","customValidations","mapContexts","skipUndefinedProperties","skipNullProperties","skipMissingProperties","nestedValidations","map","reduce","resultA","resultB","getTargetValidatorConstraints","constraintCls","customConstraintMetadata","async","ignoreAsyncValidations","stopAtFirstError","validationArguments","targetName","name","each","Array","isArray","Set","Map","validatedValue","instance","validate","promise","isValid","createValidationError","message","context","contexts","assign","arrayValue","validatedSubValues","subValue","validationIsAsync","some","validatedSubValue","asyncValidatedSubValues","resolve","asyncValidationIsFinishedPromise","all","flatValidatedValues","validationResult","every","arrayLikeValue","from","index","toString","execute","customConstraint","customConstraints","getConstraintType","customValidatorMetadata","dismissDefaultMessages","defaultMessage","Function","messageString","replaceMessageSpecialTokens"],"sourceRoot":"","sources":["../../../src/validation/ValidationExecutor.ts"],"sourcesContent":["import { Validator } from './Validator';\nimport { ValidationError } from './ValidationError';\nimport { ValidationMetadata } from '../metadata/ValidationMetadata';\nimport { ValidatorOptions } from './ValidatorOptions';\nimport { ValidationTypes } from './ValidationTypes';\nimport { ConstraintMetadata } from '../metadata/ConstraintMetadata';\nimport { ValidationArguments } from './ValidationArguments';\nimport { ValidationUtils } from './ValidationUtils';\nimport { isPromise, convertToArray } from '../utils';\nimport { getMetadataStorage } from '../metadata/MetadataStorage';\n\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n  // -------------------------------------------------------------------------\n  // Properties\n  // -------------------------------------------------------------------------\n\n  awaitingPromises: Promise<any>[] = [];\n  ignoreAsyncValidations: boolean = false;\n\n  // -------------------------------------------------------------------------\n  // Private Properties\n  // -------------------------------------------------------------------------\n\n  private metadataStorage = getMetadataStorage();\n\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n\n  constructor(private validator: Validator, private validatorOptions?: ValidatorOptions) {}\n\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  execute(object: object, targetSchema: string, validationErrors: ValidationError[]): void {\n    /**\n     * If there is no metadata registered it means possibly the dependencies are not flatterned and\n     * more than one instance is used.\n     *\n     * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n     */\n    if (!this.metadataStorage.hasValidationMetaData && this.validatorOptions?.enableDebugMessages === true) {\n      console.warn(\n        `No validation metadata found. No validation will be  performed. There are multiple possible reasons:\\n` +\n          `  - There may be multiple class-validator versions installed. You will need to flatten your dependencies to fix the issue.\\n` +\n          `  - This validation runs before any file with validation decorator was parsed by NodeJS.`\n      );\n    }\n\n    const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n    const strictGroups = (this.validatorOptions && this.validatorOptions.strictGroups) || false;\n    const always = (this.validatorOptions && this.validatorOptions.always) || false;\n    /** Forbid unknown values are turned on by default and any other value than false will enable it. */\n    const forbidUnknownValues =\n      this.validatorOptions?.forbidUnknownValues === undefined || this.validatorOptions.forbidUnknownValues !== false;\n\n    const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(\n      object.constructor,\n      targetSchema,\n      always,\n      strictGroups,\n      groups\n    );\n    const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n\n    if (this.validatorOptions && forbidUnknownValues && !targetMetadatas.length) {\n      const validationError = new ValidationError();\n\n      if (\n        !this.validatorOptions ||\n        !this.validatorOptions.validationError ||\n        this.validatorOptions.validationError.target === undefined ||\n        this.validatorOptions.validationError.target === true\n      )\n        validationError.target = object;\n\n      validationError.value = undefined;\n      validationError.property = undefined;\n      validationError.children = [];\n      validationError.constraints = { unknownValue: 'an unknown value was passed to the validate function' };\n\n      validationErrors.push(validationError);\n\n      return;\n    }\n\n    if (this.validatorOptions && this.validatorOptions.whitelist)\n      this.whitelist(object, groupedMetadatas, validationErrors);\n\n    // General validation\n    Object.keys(groupedMetadatas).forEach(propertyName => {\n      const value = (object as any)[propertyName];\n      const definedMetadatas = groupedMetadatas[propertyName].filter(\n        metadata => metadata.type === ValidationTypes.IS_DEFINED\n      );\n      const metadatas = groupedMetadatas[propertyName].filter(\n        metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST\n      );\n\n      if (\n        value instanceof Promise &&\n        metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)\n      ) {\n        this.awaitingPromises.push(\n          value.then(resolvedValue => {\n            this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n          })\n        );\n      } else {\n        this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n      }\n    });\n  }\n\n  whitelist(\n    object: any,\n    groupedMetadatas: { [propertyName: string]: ValidationMetadata[] },\n    validationErrors: ValidationError[]\n  ): void {\n    const notAllowedProperties: string[] = [];\n\n    Object.keys(object).forEach(propertyName => {\n      // does this property have no metadata?\n      if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)\n        notAllowedProperties.push(propertyName);\n    });\n\n    if (notAllowedProperties.length > 0) {\n      if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n        // throw errors\n        notAllowedProperties.forEach(property => {\n          const validationError: ValidationError = this.generateValidationError(object, object[property], property);\n          validationError.constraints = { [ValidationTypes.WHITELIST]: `property ${property} should not exist` };\n          validationError.children = undefined;\n          validationErrors.push(validationError);\n        });\n      } else {\n        // strip non allowed properties\n        notAllowedProperties.forEach(property => delete object[property]);\n      }\n    }\n  }\n\n  stripEmptyErrors(errors: ValidationError[]): ValidationError[] {\n    return errors.filter(error => {\n      if (error.children) {\n        error.children = this.stripEmptyErrors(error.children);\n      }\n\n      if (Object.keys(error.constraints).length === 0) {\n        if (error.children.length === 0) {\n          return false;\n        } else {\n          delete error.constraints;\n        }\n      }\n\n      return true;\n    });\n  }\n\n  // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n\n  private performValidations(\n    object: any,\n    value: any,\n    propertyName: string,\n    definedMetadatas: ValidationMetadata[],\n    metadatas: ValidationMetadata[],\n    validationErrors: ValidationError[]\n  ): void {\n    const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n    const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n    const conditionalValidationMetadatas = metadatas.filter(\n      metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION\n    );\n\n    const validationError = this.generateValidationError(object, value, propertyName);\n    validationErrors.push(validationError);\n\n    const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n    if (!canValidate) {\n      return;\n    }\n\n    // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n    this.customValidations(object, value, definedMetadatas, validationError);\n    this.mapContexts(object, value, definedMetadatas, validationError);\n\n    if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n      return;\n    }\n\n    if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n      return;\n    }\n\n    if (\n      (value === null || value === undefined) &&\n      this.validatorOptions &&\n      this.validatorOptions.skipMissingProperties === true\n    ) {\n      return;\n    }\n\n    this.customValidations(object, value, customValidationMetadatas, validationError);\n    this.nestedValidations(value, nestedValidationMetadatas, validationError);\n\n    this.mapContexts(object, value, metadatas, validationError);\n    this.mapContexts(object, value, customValidationMetadatas, validationError);\n  }\n\n  private generateValidationError(object: object, value: any, propertyName: string): ValidationError {\n    const validationError = new ValidationError();\n\n    if (\n      !this.validatorOptions ||\n      !this.validatorOptions.validationError ||\n      this.validatorOptions.validationError.target === undefined ||\n      this.validatorOptions.validationError.target === true\n    )\n      validationError.target = object;\n\n    if (\n      !this.validatorOptions ||\n      !this.validatorOptions.validationError ||\n      this.validatorOptions.validationError.value === undefined ||\n      this.validatorOptions.validationError.value === true\n    )\n      validationError.value = value;\n\n    validationError.property = propertyName;\n    validationError.children = [];\n    validationError.constraints = {};\n\n    return validationError;\n  }\n\n  private conditionalValidations(object: object, value: any, metadatas: ValidationMetadata[]): ValidationMetadata[] {\n    return metadatas\n      .map(metadata => metadata.constraints[0](object, value))\n      .reduce((resultA, resultB) => resultA && resultB, true);\n  }\n\n  private customValidations(object: object, value: any, metadatas: ValidationMetadata[], error: ValidationError): void {\n    metadatas.forEach(metadata => {\n      this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls).forEach(customConstraintMetadata => {\n        if (customConstraintMetadata.async && this.ignoreAsyncValidations) return;\n        if (\n          this.validatorOptions &&\n          this.validatorOptions.stopAtFirstError &&\n          Object.keys(error.constraints || {}).length > 0\n        )\n          return;\n\n        const validationArguments: ValidationArguments = {\n          targetName: object.constructor ? (object.constructor as any).name : undefined,\n          property: metadata.propertyName,\n          object: object,\n          value: value,\n          constraints: metadata.constraints,\n        };\n\n        if (!metadata.each || !(Array.isArray(value) || value instanceof Set || value instanceof Map)) {\n          const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n          if (isPromise(validatedValue)) {\n            const promise = validatedValue.then(isValid => {\n              if (!isValid) {\n                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                error.constraints[type] = message;\n                if (metadata.context) {\n                  if (!error.contexts) {\n                    error.contexts = {};\n                  }\n                  error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);\n                }\n              }\n            });\n            this.awaitingPromises.push(promise);\n          } else {\n            if (!validatedValue) {\n              const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n              error.constraints[type] = message;\n            }\n          }\n\n          return;\n        }\n\n        // convert set and map into array\n        const arrayValue = convertToArray(value);\n        // Validation needs to be applied to each array item\n        const validatedSubValues = arrayValue.map((subValue: any) =>\n          customConstraintMetadata.instance.validate(subValue, validationArguments)\n        );\n        const validationIsAsync = validatedSubValues.some((validatedSubValue: boolean | Promise<boolean>) =>\n          isPromise(validatedSubValue)\n        );\n\n        if (validationIsAsync) {\n          // Wrap plain values (if any) in promises, so that all are async\n          const asyncValidatedSubValues = validatedSubValues.map((validatedSubValue: boolean | Promise<boolean>) =>\n            isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue)\n          );\n          const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues).then(\n            (flatValidatedValues: boolean[]) => {\n              const validationResult = flatValidatedValues.every((isValid: boolean) => isValid);\n              if (!validationResult) {\n                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                error.constraints[type] = message;\n                if (metadata.context) {\n                  if (!error.contexts) {\n                    error.contexts = {};\n                  }\n                  error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);\n                }\n              }\n            }\n          );\n\n          this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n\n          return;\n        }\n\n        const validationResult = validatedSubValues.every((isValid: boolean) => isValid);\n        if (!validationResult) {\n          const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n          error.constraints[type] = message;\n        }\n      });\n    });\n  }\n\n  private nestedValidations(value: any, metadatas: ValidationMetadata[], error: ValidationError): void {\n    if (value === void 0) {\n      return;\n    }\n\n    metadatas.forEach(metadata => {\n      if (metadata.type !== ValidationTypes.NESTED_VALIDATION && metadata.type !== ValidationTypes.PROMISE_VALIDATION) {\n        return;\n      } else if (\n        this.validatorOptions &&\n        this.validatorOptions.stopAtFirstError &&\n        Object.keys(error.constraints || {}).length > 0\n      ) {\n        return;\n      }\n\n      if (Array.isArray(value) || value instanceof Set || value instanceof Map) {\n        // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n        const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n        arrayLikeValue.forEach((subValue: any, index: any) => {\n          this.performValidations(value, subValue, index.toString(), [], metadatas, error.children);\n        });\n      } else if (value instanceof Object) {\n        const targetSchema = typeof metadata.target === 'string' ? metadata.target : metadata.target.name;\n        this.execute(value, targetSchema, error.children);\n      } else {\n        const [type, message] = this.createValidationError(metadata.target as object, value, metadata);\n        error.constraints[type] = message;\n      }\n    });\n  }\n\n  private mapContexts(object: object, value: any, metadatas: ValidationMetadata[], error: ValidationError): void {\n    return metadatas.forEach(metadata => {\n      if (metadata.context) {\n        let customConstraint;\n        if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {\n          const customConstraints = this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);\n          customConstraint = customConstraints[0];\n        }\n\n        const type = this.getConstraintType(metadata, customConstraint);\n\n        if (error.constraints[type]) {\n          if (!error.contexts) {\n            error.contexts = {};\n          }\n\n          error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);\n        }\n      }\n    });\n  }\n\n  private createValidationError(\n    object: object,\n    value: any,\n    metadata: ValidationMetadata,\n    customValidatorMetadata?: ConstraintMetadata\n  ): [string, string] {\n    const targetName = object.constructor ? (object.constructor as any).name : undefined;\n    const type = this.getConstraintType(metadata, customValidatorMetadata);\n    const validationArguments: ValidationArguments = {\n      targetName: targetName,\n      property: metadata.propertyName,\n      object: object,\n      value: value,\n      constraints: metadata.constraints,\n    };\n\n    let message = metadata.message || '';\n    if (\n      !metadata.message &&\n      (!this.validatorOptions || (this.validatorOptions && !this.validatorOptions.dismissDefaultMessages))\n    ) {\n      if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n        message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n      }\n    }\n\n    const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n    return [type, messageString];\n  }\n\n  private getConstraintType(metadata: ValidationMetadata, customValidatorMetadata?: ConstraintMetadata): string {\n    const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n    return type;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}