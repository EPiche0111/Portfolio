{"ast":null,"code":"import { buildMessage, ValidateBy } from '../common/ValidateBy';\nimport isHashValidator from 'validator/lib/isHash';\nexport var IS_HASH = 'isHash';\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function isHash(value, algorithm) {\n  return typeof value === 'string' && isHashValidator(value, algorithm);\n}\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function IsHash(algorithm, validationOptions) {\n  return ValidateBy({\n    name: IS_HASH,\n    constraints: [algorithm],\n    validator: {\n      validate: function (value, args) {\n        return isHash(value, args === null || args === void 0 ? void 0 : args.constraints[0]);\n      },\n      defaultMessage: buildMessage(function (eachPrefix) {\n        return eachPrefix + '$property must be a hash of type $constraint1';\n      }, validationOptions)\n    }\n  }, validationOptions);\n}","map":{"version":3,"mappings":"AACA,SAASA,YAAY,EAAEC,UAAU,QAAQ,sBAAsB;AAC/D,OAAOC,eAAe,MAAM,sBAAsB;AAGlD,OAAO,IAAMC,OAAO,GAAG,QAAQ;AAE/B;;;;;AAKA,OAAM,SAAUC,MAAMA,CAACC,KAAc,EAAEC,SAAoC;EACzE,OAAO,OAAOD,KAAK,KAAK,QAAQ,IAAIH,eAAe,CAACG,KAAK,EAAEC,SAAS,CAAC;AACvE;AAEA;;;;;AAKA,OAAM,SAAUC,MAAMA,CAACD,SAAiB,EAAEE,iBAAqC;EAC7E,OAAOP,UAAU,CACf;IACEQ,IAAI,EAAEN,OAAO;IACbO,WAAW,EAAE,CAACJ,SAAS,CAAC;IACxBK,SAAS,EAAE;MACTC,QAAQ,EAAE,UAACP,KAAK,EAAEQ,IAAI;QAAc,aAAM,CAACR,KAAK,EAAEQ,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEH,WAAW,CAAC,CAAC,CAAC,CAAC;MAAnC,CAAmC;MACvEI,cAAc,EAAEd,YAAY,CAC1B,oBAAU;QAAI,iBAAU,GAAG,+CAA+C;MAA5D,CAA4D,EAC1EQ,iBAAiB;;GAGtB,EACDA,iBAAiB,CAClB;AACH","names":["buildMessage","ValidateBy","isHashValidator","IS_HASH","isHash","value","algorithm","IsHash","validationOptions","name","constraints","validator","validate","args","defaultMessage"],"sourceRoot":"","sources":["../../../../src/decorator/string/IsHash.ts"],"sourcesContent":["import { ValidationOptions } from '../ValidationOptions';\nimport { buildMessage, ValidateBy } from '../common/ValidateBy';\nimport isHashValidator from 'validator/lib/isHash';\nimport ValidatorJS from 'validator';\n\nexport const IS_HASH = 'isHash';\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function isHash(value: unknown, algorithm: ValidatorJS.HashAlgorithm): boolean {\n  return typeof value === 'string' && isHashValidator(value, algorithm);\n}\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function IsHash(algorithm: string, validationOptions?: ValidationOptions): PropertyDecorator {\n  return ValidateBy(\n    {\n      name: IS_HASH,\n      constraints: [algorithm],\n      validator: {\n        validate: (value, args): boolean => isHash(value, args?.constraints[0]),\n        defaultMessage: buildMessage(\n          eachPrefix => eachPrefix + '$property must be a hash of type $constraint1',\n          validationOptions\n        ),\n      },\n    },\n    validationOptions\n  );\n}\n"]},"metadata":{},"sourceType":"module"}