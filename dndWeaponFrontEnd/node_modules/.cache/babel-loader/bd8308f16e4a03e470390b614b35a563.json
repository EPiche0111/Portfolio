{"ast":null,"code":"/**\n * Convert the constraint to a string to be shown in an error\n */\nexport function constraintToString(constraint) {\n  if (Array.isArray(constraint)) {\n    return constraint.join(', ');\n  }\n  if (typeof constraint === 'symbol') {\n    constraint = constraint.description;\n  }\n  return \"\".concat(constraint);\n}\nvar ValidationUtils = /** @class */function () {\n  function ValidationUtils() {}\n  ValidationUtils.replaceMessageSpecialTokens = function (message, validationArguments) {\n    var messageString;\n    if (message instanceof Function) {\n      messageString = message(validationArguments);\n    } else if (typeof message === 'string') {\n      messageString = message;\n    }\n    if (messageString && Array.isArray(validationArguments.constraints)) {\n      validationArguments.constraints.forEach(function (constraint, index) {\n        messageString = messageString.replace(new RegExp(\"\\\\$constraint\".concat(index + 1), 'g'), constraintToString(constraint));\n      });\n    }\n    if (messageString && validationArguments.value !== undefined && validationArguments.value !== null && typeof validationArguments.value === 'string') messageString = messageString.replace(/\\$value/g, validationArguments.value);\n    if (messageString) messageString = messageString.replace(/\\$property/g, validationArguments.property);\n    if (messageString) messageString = messageString.replace(/\\$target/g, validationArguments.targetName);\n    return messageString;\n  };\n  return ValidationUtils;\n}();\nexport { ValidationUtils };","map":{"version":3,"mappings":"AAEA;;;AAGA,OAAM,SAAUA,kBAAkBA,CAACC,UAAmB;EACpD,IAAIC,KAAK,CAACC,OAAO,CAACF,UAAU,CAAC,EAAE;IAC7B,OAAOA,UAAU,CAACG,IAAI,CAAC,IAAI,CAAC;;EAG9B,IAAI,OAAOH,UAAU,KAAK,QAAQ,EAAE;IAClCA,UAAU,GAAGA,UAAU,CAACI,WAAW;;EAGrC,OAAO,UAAGJ,UAAU,CAAE;AACxB;AAEA;EAAA,4BAiCA;EAhCSK,2CAA2B,GAAlC,UACEC,OAAyD,EACzDC,mBAAwC;IAExC,IAAIC,aAAqB;IACzB,IAAIF,OAAO,YAAYG,QAAQ,EAAE;MAC/BD,aAAa,GAAIF,OAAiD,CAACC,mBAAmB,CAAC;KACxF,MAAM,IAAI,OAAOD,OAAO,KAAK,QAAQ,EAAE;MACtCE,aAAa,GAAGF,OAAO;;IAGzB,IAAIE,aAAa,IAAIP,KAAK,CAACC,OAAO,CAACK,mBAAmB,CAACG,WAAW,CAAC,EAAE;MACnEH,mBAAmB,CAACG,WAAW,CAACC,OAAO,CAAC,UAACX,UAAU,EAAEY,KAAK;QACxDJ,aAAa,GAAGA,aAAa,CAACK,OAAO,CACnC,IAAIC,MAAM,CAAC,uBAAgBF,KAAK,GAAG,CAAC,CAAE,EAAE,GAAG,CAAC,EAC5Cb,kBAAkB,CAACC,UAAU,CAAC,CAC/B;MACH,CAAC,CAAC;;IAGJ,IACEQ,aAAa,IACbD,mBAAmB,CAACQ,KAAK,KAAKC,SAAS,IACvCT,mBAAmB,CAACQ,KAAK,KAAK,IAAI,IAClC,OAAOR,mBAAmB,CAACQ,KAAK,KAAK,QAAQ,EAE7CP,aAAa,GAAGA,aAAa,CAACK,OAAO,CAAC,UAAU,EAAEN,mBAAmB,CAACQ,KAAK,CAAC;IAC9E,IAAIP,aAAa,EAAEA,aAAa,GAAGA,aAAa,CAACK,OAAO,CAAC,aAAa,EAAEN,mBAAmB,CAACU,QAAQ,CAAC;IACrG,IAAIT,aAAa,EAAEA,aAAa,GAAGA,aAAa,CAACK,OAAO,CAAC,WAAW,EAAEN,mBAAmB,CAACW,UAAU,CAAC;IAErG,OAAOV,aAAa;EACtB,CAAC;EACH,sBAAC;AAAD,CAAC,CAjCD","names":["constraintToString","constraint","Array","isArray","join","description","ValidationUtils","message","validationArguments","messageString","Function","constraints","forEach","index","replace","RegExp","value","undefined","property","targetName"],"sourceRoot":"","sources":["../../../src/validation/ValidationUtils.ts"],"sourcesContent":["import { ValidationArguments } from './ValidationArguments';\n\n/**\n * Convert the constraint to a string to be shown in an error\n */\nexport function constraintToString(constraint: unknown): string {\n  if (Array.isArray(constraint)) {\n    return constraint.join(', ');\n  }\n\n  if (typeof constraint === 'symbol') {\n    constraint = constraint.description;\n  }\n\n  return `${constraint}`;\n}\n\nexport class ValidationUtils {\n  static replaceMessageSpecialTokens(\n    message: string | ((args: ValidationArguments) => string),\n    validationArguments: ValidationArguments\n  ): string {\n    let messageString: string;\n    if (message instanceof Function) {\n      messageString = (message as (args: ValidationArguments) => string)(validationArguments);\n    } else if (typeof message === 'string') {\n      messageString = message;\n    }\n\n    if (messageString && Array.isArray(validationArguments.constraints)) {\n      validationArguments.constraints.forEach((constraint, index) => {\n        messageString = messageString.replace(\n          new RegExp(`\\\\$constraint${index + 1}`, 'g'),\n          constraintToString(constraint)\n        );\n      });\n    }\n\n    if (\n      messageString &&\n      validationArguments.value !== undefined &&\n      validationArguments.value !== null &&\n      typeof validationArguments.value === 'string'\n    )\n      messageString = messageString.replace(/\\$value/g, validationArguments.value);\n    if (messageString) messageString = messageString.replace(/\\$property/g, validationArguments.property);\n    if (messageString) messageString = messageString.replace(/\\$target/g, validationArguments.targetName);\n\n    return messageString;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}