{"ast":null,"code":"import { ConstraintMetadata } from './metadata/ConstraintMetadata';\nimport { ValidationMetadata } from './metadata/ValidationMetadata';\nimport { ValidationTypes } from './validation/ValidationTypes';\nimport { getFromContainer } from './container';\nimport { MetadataStorage, getMetadataStorage } from './metadata/MetadataStorage';\n/**\n * Registers a custom validation decorator.\n */\nexport function registerDecorator(options) {\n  var constraintCls;\n  if (options.validator instanceof Function) {\n    constraintCls = options.validator;\n    var constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n    if (constraintClasses.length > 1) {\n      throw \"More than one implementation of ValidatorConstraintInterface found for validator on: \".concat(options.target.name, \":\").concat(options.propertyName);\n    }\n  } else {\n    var validator_1 = options.validator;\n    constraintCls = /** @class */function () {\n      function CustomConstraint() {}\n      CustomConstraint.prototype.validate = function (value, validationArguments) {\n        return validator_1.validate(value, validationArguments);\n      };\n      CustomConstraint.prototype.defaultMessage = function (validationArguments) {\n        if (validator_1.defaultMessage) {\n          return validator_1.defaultMessage(validationArguments);\n        }\n        return '';\n      };\n      return CustomConstraint;\n    }();\n    getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n  }\n  var validationMetadataArgs = {\n    type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n    name: options.name,\n    target: options.target,\n    propertyName: options.propertyName,\n    validationOptions: options.options,\n    constraintCls: constraintCls,\n    constraints: options.constraints\n  };\n  getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n}","map":{"version":3,"mappings":"AAAA,SAASA,kBAAkB,QAAQ,+BAA+B;AAElE,SAASC,kBAAkB,QAAQ,+BAA+B;AAElE,SAASC,eAAe,QAAQ,8BAA8B;AAE9D,SAASC,gBAAgB,QAAQ,aAAa;AAC9C,SAASC,eAAe,EAAEC,kBAAkB,QAAQ,4BAA4B;AAwChF;;;AAGA,OAAM,SAAUC,iBAAiBA,CAACC,OAAmC;EACnE,IAAIC,aAAuB;EAC3B,IAAID,OAAO,CAACE,SAAS,YAAYC,QAAQ,EAAE;IACzCF,aAAa,GAAGD,OAAO,CAACE,SAAS;IACjC,IAAME,iBAAiB,GAAGR,gBAAgB,CAACC,eAAe,CAAC,CAACQ,6BAA6B,CAACL,OAAO,CAACE,SAAS,CAAC;IAC5G,IAAIE,iBAAiB,CAACE,MAAM,GAAG,CAAC,EAAE;MAChC,MAAM,+FAAwFN,OAAO,CAACO,MAAM,CAACC,IAAI,cAAIR,OAAO,CAACS,YAAY,CAAE;;GAE9I,MAAM;IACL,IAAMC,WAAS,GAAGV,OAAO,CAACE,SAAS;IACnCD,aAAa;MAAG,6BAYhB;MAXEU,mCAAQ,GAAR,UAASC,KAAU,EAAEC,mBAAyC;QAC5D,OAAOH,WAAS,CAACI,QAAQ,CAACF,KAAK,EAAEC,mBAAmB,CAAC;MACvD,CAAC;MAEDF,yCAAc,GAAd,UAAeE,mBAAyC;QACtD,IAAIH,WAAS,CAACK,cAAc,EAAE;UAC5B,OAAOL,WAAS,CAACK,cAAc,CAACF,mBAAmB,CAAC;;QAGtD,OAAO,EAAE;MACX,CAAC;MACH,uBAAC;IAAD,CAAC,CAZe,CAYf;IACDf,kBAAkB,EAAE,CAACkB,qBAAqB,CAAC,IAAIvB,kBAAkB,CAACQ,aAAa,EAAED,OAAO,CAACQ,IAAI,EAAER,OAAO,CAACiB,KAAK,CAAC,CAAC;;EAGhH,IAAMC,sBAAsB,GAA2B;IACrDC,IAAI,EAAEnB,OAAO,CAACQ,IAAI,IAAIb,eAAe,CAACyB,OAAO,CAACpB,OAAO,CAACQ,IAAI,CAAC,GAAGR,OAAO,CAACQ,IAAI,GAAGb,eAAe,CAAC0B,iBAAiB;IAC9Gb,IAAI,EAAER,OAAO,CAACQ,IAAI;IAClBD,MAAM,EAAEP,OAAO,CAACO,MAAM;IACtBE,YAAY,EAAET,OAAO,CAACS,YAAY;IAClCa,iBAAiB,EAAEtB,OAAO,CAACA,OAAO;IAClCC,aAAa,EAAEA,aAAa;IAC5BsB,WAAW,EAAEvB,OAAO,CAACuB;GACtB;EACDzB,kBAAkB,EAAE,CAAC0B,qBAAqB,CAAC,IAAI9B,kBAAkB,CAACwB,sBAAsB,CAAC,CAAC;AAC5F","names":["ConstraintMetadata","ValidationMetadata","ValidationTypes","getFromContainer","MetadataStorage","getMetadataStorage","registerDecorator","options","constraintCls","validator","Function","constraintClasses","getTargetValidatorConstraints","length","target","name","propertyName","validator_1","CustomConstraint","value","validationArguments","validate","defaultMessage","addConstraintMetadata","async","validationMetadataArgs","type","isValid","CUSTOM_VALIDATION","validationOptions","constraints","addValidationMetadata"],"sourceRoot":"","sources":["../../src/register-decorator.ts"],"sourcesContent":["import { ConstraintMetadata } from './metadata/ConstraintMetadata';\nimport { ValidatorConstraintInterface } from './validation/ValidatorConstraintInterface';\nimport { ValidationMetadata } from './metadata/ValidationMetadata';\nimport { ValidationMetadataArgs } from './metadata/ValidationMetadataArgs';\nimport { ValidationTypes } from './validation/ValidationTypes';\nimport { ValidationArguments } from './validation/ValidationArguments';\nimport { getFromContainer } from './container';\nimport { MetadataStorage, getMetadataStorage } from './metadata/MetadataStorage';\nimport { ValidationOptions } from './decorator/ValidationOptions';\n\nexport interface ValidationDecoratorOptions {\n  /**\n   * Target object to be validated.\n   */\n  target: Function;\n\n  /**\n   * Target object's property name to be validated.\n   */\n  propertyName: string;\n\n  /**\n   * Name of the validation that is being registered.\n   */\n  name?: string;\n\n  /**\n   * Indicates if this decorator will perform async validation.\n   */\n  async?: boolean;\n\n  /**\n   * Validator options.\n   */\n  options?: ValidationOptions;\n\n  /**\n   * Array of validation constraints.\n   */\n  constraints?: any[];\n\n  /**\n   * Validator that performs validation.\n   */\n  validator: ValidatorConstraintInterface | Function;\n}\n\n/**\n * Registers a custom validation decorator.\n */\nexport function registerDecorator(options: ValidationDecoratorOptions): void {\n  let constraintCls: Function;\n  if (options.validator instanceof Function) {\n    constraintCls = options.validator;\n    const constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n    if (constraintClasses.length > 1) {\n      throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target.name}:${options.propertyName}`;\n    }\n  } else {\n    const validator = options.validator;\n    constraintCls = class CustomConstraint implements ValidatorConstraintInterface {\n      validate(value: any, validationArguments?: ValidationArguments): Promise<boolean> | boolean {\n        return validator.validate(value, validationArguments);\n      }\n\n      defaultMessage(validationArguments?: ValidationArguments): string {\n        if (validator.defaultMessage) {\n          return validator.defaultMessage(validationArguments);\n        }\n\n        return '';\n      }\n    };\n    getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n  }\n\n  const validationMetadataArgs: ValidationMetadataArgs = {\n    type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n    name: options.name,\n    target: options.target,\n    propertyName: options.propertyName,\n    validationOptions: options.options,\n    constraintCls: constraintCls,\n    constraints: options.constraints,\n  };\n  getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n}\n"]},"metadata":{},"sourceType":"module"}