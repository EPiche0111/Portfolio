{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport { ValidationTypes } from '../../validation/ValidationTypes';\nimport { ValidationMetadata } from '../../metadata/ValidationMetadata';\nimport { getMetadataStorage } from '../../metadata/MetadataStorage';\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateNested(validationOptions) {\n  var opts = __assign({}, validationOptions);\n  var eachPrefix = opts.each ? 'each value in ' : '';\n  opts.message = opts.message || eachPrefix + 'nested property $property must be either object or array';\n  return function (object, propertyName) {\n    var args = {\n      type: ValidationTypes.NESTED_VALIDATION,\n      target: object.constructor,\n      propertyName: propertyName,\n      validationOptions: opts\n    };\n    getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n  };\n}","map":{"version":3,"mappings":";;;;;;;;;;AAEA,SAASA,eAAe,QAAQ,kCAAkC;AAClE,SAASC,kBAAkB,QAAQ,mCAAmC;AACtE,SAASC,kBAAkB,QAAQ,gCAAgC;AAEnE;;;AAGA,OAAM,SAAUC,cAAcA,CAACC,iBAAqC;EAClE,IAAMC,IAAI,gBAA2BD,iBAAiB,CAAE;EACxD,IAAME,UAAU,GAAGD,IAAI,CAACE,IAAI,GAAG,gBAAgB,GAAG,EAAE;EACpDF,IAAI,CAACG,OAAO,GAAGH,IAAI,CAACG,OAAO,IAAIF,UAAU,GAAG,0DAA0D;EAEtG,OAAO,UAAUG,MAAc,EAAEC,YAAoB;IACnD,IAAMC,IAAI,GAA2B;MACnCC,IAAI,EAAEZ,eAAe,CAACa,iBAAiB;MACvCC,MAAM,EAAEL,MAAM,CAACM,WAAW;MAC1BL,YAAY,EAAEA,YAAY;MAC1BN,iBAAiB,EAAEC;KACpB;IACDH,kBAAkB,EAAE,CAACc,qBAAqB,CAAC,IAAIf,kBAAkB,CAACU,IAAI,CAAC,CAAC;EAC1E,CAAC;AACH","names":["ValidationTypes","ValidationMetadata","getMetadataStorage","ValidateNested","validationOptions","opts","eachPrefix","each","message","object","propertyName","args","type","NESTED_VALIDATION","target","constructor","addValidationMetadata"],"sourceRoot":"","sources":["../../../../src/decorator/common/ValidateNested.ts"],"sourcesContent":["import { ValidationOptions } from '../ValidationOptions';\nimport { ValidationMetadataArgs } from '../../metadata/ValidationMetadataArgs';\nimport { ValidationTypes } from '../../validation/ValidationTypes';\nimport { ValidationMetadata } from '../../metadata/ValidationMetadata';\nimport { getMetadataStorage } from '../../metadata/MetadataStorage';\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateNested(validationOptions?: ValidationOptions): PropertyDecorator {\n  const opts: ValidationOptions = { ...validationOptions };\n  const eachPrefix = opts.each ? 'each value in ' : '';\n  opts.message = opts.message || eachPrefix + 'nested property $property must be either object or array';\n\n  return function (object: object, propertyName: string): void {\n    const args: ValidationMetadataArgs = {\n      type: ValidationTypes.NESTED_VALIDATION,\n      target: object.constructor,\n      propertyName: propertyName,\n      validationOptions: opts,\n    };\n    getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n  };\n}\n"]},"metadata":{},"sourceType":"module"}