{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { ValidationSchemaToMetadataTransformer } from '../validation-schema/ValidationSchemaToMetadataTransformer';\nimport { getGlobal } from '../utils';\n/**\n * Storage all metadatas.\n */\nvar MetadataStorage = /** @class */function () {\n  function MetadataStorage() {\n    // -------------------------------------------------------------------------\n    // Private properties\n    // -------------------------------------------------------------------------\n    this.validationMetadatas = new Map();\n    this.constraintMetadatas = new Map();\n  }\n  Object.defineProperty(MetadataStorage.prototype, \"hasValidationMetaData\", {\n    get: function () {\n      return !!this.validationMetadatas.size;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Adds a new validation metadata.\n   */\n  MetadataStorage.prototype.addValidationSchema = function (schema) {\n    var _this = this;\n    var validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\n    validationMetadatas.forEach(function (validationMetadata) {\n      return _this.addValidationMetadata(validationMetadata);\n    });\n  };\n  /**\n   * Adds a new validation metadata.\n   */\n  MetadataStorage.prototype.addValidationMetadata = function (metadata) {\n    var existingMetadata = this.validationMetadatas.get(metadata.target);\n    if (existingMetadata) {\n      existingMetadata.push(metadata);\n    } else {\n      this.validationMetadatas.set(metadata.target, [metadata]);\n    }\n  };\n  /**\n   * Adds a new constraint metadata.\n   */\n  MetadataStorage.prototype.addConstraintMetadata = function (metadata) {\n    var existingMetadata = this.constraintMetadatas.get(metadata.target);\n    if (existingMetadata) {\n      existingMetadata.push(metadata);\n    } else {\n      this.constraintMetadatas.set(metadata.target, [metadata]);\n    }\n  };\n  /**\n   * Groups metadata by their property names.\n   */\n  MetadataStorage.prototype.groupByPropertyName = function (metadata) {\n    var grouped = {};\n    metadata.forEach(function (metadata) {\n      if (!grouped[metadata.propertyName]) grouped[metadata.propertyName] = [];\n      grouped[metadata.propertyName].push(metadata);\n    });\n    return grouped;\n  };\n  /**\n   * Gets all validation metadatas for the given object with the given groups.\n   */\n  MetadataStorage.prototype.getTargetValidationMetadatas = function (targetConstructor, targetSchema, always, strictGroups, groups) {\n    var e_1, _a;\n    var includeMetadataBecauseOfAlwaysOption = function (metadata) {\n      // `metadata.always` overrides global default.\n      if (typeof metadata.always !== 'undefined') return metadata.always;\n      // `metadata.groups` overrides global default.\n      if (metadata.groups && metadata.groups.length) return false;\n      // Use global default.\n      return always;\n    };\n    var excludeMetadataBecauseOfStrictGroupsOption = function (metadata) {\n      if (strictGroups) {\n        // Validation is not using groups.\n        if (!groups || !groups.length) {\n          // `metadata.groups` has at least one group.\n          if (metadata.groups && metadata.groups.length) return true;\n        }\n      }\n      return false;\n    };\n    // get directly related to a target metadatas\n    var filteredForOriginalMetadatasSearch = this.validationMetadatas.get(targetConstructor) || [];\n    var originalMetadatas = filteredForOriginalMetadatasSearch.filter(function (metadata) {\n      if (metadata.target !== targetConstructor && metadata.target !== targetSchema) return false;\n      if (includeMetadataBecauseOfAlwaysOption(metadata)) return true;\n      if (excludeMetadataBecauseOfStrictGroupsOption(metadata)) return false;\n      if (groups && groups.length > 0) return metadata.groups && !!metadata.groups.find(function (group) {\n        return groups.indexOf(group) !== -1;\n      });\n      return true;\n    });\n    // get metadatas for inherited classes\n    var filteredForInheritedMetadatasSearch = [];\n    try {\n      for (var _b = __values(this.validationMetadatas.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = __read(_c.value, 2),\n          key = _d[0],\n          value = _d[1];\n        if (targetConstructor.prototype instanceof key) {\n          filteredForInheritedMetadatasSearch.push.apply(filteredForInheritedMetadatasSearch, __spreadArray([], __read(value), false));\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    var inheritedMetadatas = filteredForInheritedMetadatasSearch.filter(function (metadata) {\n      // if target is a string it's means we validate against a schema, and there is no inheritance support for schemas\n      if (typeof metadata.target === 'string') return false;\n      if (metadata.target === targetConstructor) return false;\n      if (metadata.target instanceof Function && !(targetConstructor.prototype instanceof metadata.target)) return false;\n      if (includeMetadataBecauseOfAlwaysOption(metadata)) return true;\n      if (excludeMetadataBecauseOfStrictGroupsOption(metadata)) return false;\n      if (groups && groups.length > 0) return metadata.groups && !!metadata.groups.find(function (group) {\n        return groups.indexOf(group) !== -1;\n      });\n      return true;\n    });\n    // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\n    var uniqueInheritedMetadatas = inheritedMetadatas.filter(function (inheritedMetadata) {\n      return !originalMetadatas.find(function (originalMetadata) {\n        return originalMetadata.propertyName === inheritedMetadata.propertyName && originalMetadata.type === inheritedMetadata.type;\n      });\n    });\n    return originalMetadatas.concat(uniqueInheritedMetadatas);\n  };\n  /**\n   * Gets all validator constraints for the given object.\n   */\n  MetadataStorage.prototype.getTargetValidatorConstraints = function (target) {\n    return this.constraintMetadatas.get(target) || [];\n  };\n  return MetadataStorage;\n}();\nexport { MetadataStorage };\n/**\n * Gets metadata storage.\n * Metadata storage follows the best practices and stores metadata in a global variable.\n */\nexport function getMetadataStorage() {\n  var global = getGlobal();\n  if (!global.classValidatorMetadataStorage) {\n    global.classValidatorMetadataStorage = new MetadataStorage();\n  }\n  return global.classValidatorMetadataStorage;\n}","map":{"version":3,"mappings":"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","names":["ValidationSchemaToMetadataTransformer","getGlobal","Map","Object","MetadataStorage","validationMetadatas","size","schema","transform","forEach","addValidationMetadata","validationMetadata","metadata","existingMetadata","get","target","push","set","constraintMetadatas","grouped","propertyName","targetConstructor","targetSchema","always","strictGroups","groups","includeMetadataBecauseOfAlwaysOption","length","excludeMetadataBecauseOfStrictGroupsOption","filteredForOriginalMetadatasSearch","originalMetadatas","filter","find","indexOf","group","filteredForInheritedMetadatasSearch","entries","key","value","prototype","inheritedMetadatas","Function","uniqueInheritedMetadatas","originalMetadata","inheritedMetadata","type","concat","getMetadataStorage","global","classValidatorMetadataStorage"],"sourceRoot":"","sources":["../../../src/metadata/MetadataStorage.ts"],"sourcesContent":["import { ValidationMetadata } from './ValidationMetadata';\nimport { ConstraintMetadata } from './ConstraintMetadata';\nimport { ValidationSchema } from '../validation-schema/ValidationSchema';\nimport { ValidationSchemaToMetadataTransformer } from '../validation-schema/ValidationSchemaToMetadataTransformer';\nimport { getGlobal } from '../utils';\n\n/**\n * Storage all metadatas.\n */\nexport class MetadataStorage {\n  // -------------------------------------------------------------------------\n  // Private properties\n  // -------------------------------------------------------------------------\n\n  private validationMetadatas: Map<any, ValidationMetadata[]> = new Map();\n  private constraintMetadatas: Map<any, ConstraintMetadata[]> = new Map();\n\n  get hasValidationMetaData(): boolean {\n    return !!this.validationMetadatas.size;\n  }\n\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Adds a new validation metadata.\n   */\n  addValidationSchema(schema: ValidationSchema): void {\n    const validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\n    validationMetadatas.forEach(validationMetadata => this.addValidationMetadata(validationMetadata));\n  }\n\n  /**\n   * Adds a new validation metadata.\n   */\n  addValidationMetadata(metadata: ValidationMetadata): void {\n    const existingMetadata = this.validationMetadatas.get(metadata.target);\n\n    if (existingMetadata) {\n      existingMetadata.push(metadata);\n    } else {\n      this.validationMetadatas.set(metadata.target, [metadata]);\n    }\n  }\n\n  /**\n   * Adds a new constraint metadata.\n   */\n  addConstraintMetadata(metadata: ConstraintMetadata): void {\n    const existingMetadata = this.constraintMetadatas.get(metadata.target);\n\n    if (existingMetadata) {\n      existingMetadata.push(metadata);\n    } else {\n      this.constraintMetadatas.set(metadata.target, [metadata]);\n    }\n  }\n\n  /**\n   * Groups metadata by their property names.\n   */\n  groupByPropertyName(metadata: ValidationMetadata[]): { [propertyName: string]: ValidationMetadata[] } {\n    const grouped: { [propertyName: string]: ValidationMetadata[] } = {};\n    metadata.forEach(metadata => {\n      if (!grouped[metadata.propertyName]) grouped[metadata.propertyName] = [];\n      grouped[metadata.propertyName].push(metadata);\n    });\n    return grouped;\n  }\n\n  /**\n   * Gets all validation metadatas for the given object with the given groups.\n   */\n  getTargetValidationMetadatas(\n    targetConstructor: Function,\n    targetSchema: string,\n    always: boolean,\n    strictGroups: boolean,\n    groups?: string[]\n  ): ValidationMetadata[] {\n    const includeMetadataBecauseOfAlwaysOption = (metadata: ValidationMetadata): boolean => {\n      // `metadata.always` overrides global default.\n      if (typeof metadata.always !== 'undefined') return metadata.always;\n\n      // `metadata.groups` overrides global default.\n      if (metadata.groups && metadata.groups.length) return false;\n\n      // Use global default.\n      return always;\n    };\n\n    const excludeMetadataBecauseOfStrictGroupsOption = (metadata: ValidationMetadata): boolean => {\n      if (strictGroups) {\n        // Validation is not using groups.\n        if (!groups || !groups.length) {\n          // `metadata.groups` has at least one group.\n          if (metadata.groups && metadata.groups.length) return true;\n        }\n      }\n\n      return false;\n    };\n\n    // get directly related to a target metadatas\n    const filteredForOriginalMetadatasSearch = this.validationMetadatas.get(targetConstructor) || [];\n    const originalMetadatas = filteredForOriginalMetadatasSearch.filter(metadata => {\n      if (metadata.target !== targetConstructor && metadata.target !== targetSchema) return false;\n      if (includeMetadataBecauseOfAlwaysOption(metadata)) return true;\n      if (excludeMetadataBecauseOfStrictGroupsOption(metadata)) return false;\n      if (groups && groups.length > 0)\n        return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n      return true;\n    });\n\n    // get metadatas for inherited classes\n    const filteredForInheritedMetadatasSearch = [];\n    for (const [key, value] of this.validationMetadatas.entries()) {\n      if (targetConstructor.prototype instanceof key) {\n        filteredForInheritedMetadatasSearch.push(...value);\n      }\n    }\n    const inheritedMetadatas = filteredForInheritedMetadatasSearch.filter(metadata => {\n      // if target is a string it's means we validate against a schema, and there is no inheritance support for schemas\n      if (typeof metadata.target === 'string') return false;\n      if (metadata.target === targetConstructor) return false;\n      if (metadata.target instanceof Function && !(targetConstructor.prototype instanceof metadata.target))\n        return false;\n      if (includeMetadataBecauseOfAlwaysOption(metadata)) return true;\n      if (excludeMetadataBecauseOfStrictGroupsOption(metadata)) return false;\n      if (groups && groups.length > 0)\n        return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n      return true;\n    });\n\n    // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\n    const uniqueInheritedMetadatas = inheritedMetadatas.filter(inheritedMetadata => {\n      return !originalMetadatas.find(originalMetadata => {\n        return (\n          originalMetadata.propertyName === inheritedMetadata.propertyName &&\n          originalMetadata.type === inheritedMetadata.type\n        );\n      });\n    });\n\n    return originalMetadatas.concat(uniqueInheritedMetadatas);\n  }\n\n  /**\n   * Gets all validator constraints for the given object.\n   */\n  getTargetValidatorConstraints(target: Function): ConstraintMetadata[] {\n    return this.constraintMetadatas.get(target) || [];\n  }\n}\n\n/**\n * Gets metadata storage.\n * Metadata storage follows the best practices and stores metadata in a global variable.\n */\nexport function getMetadataStorage(): MetadataStorage {\n  const global = getGlobal();\n\n  if (!global.classValidatorMetadataStorage) {\n    global.classValidatorMetadataStorage = new MetadataStorage();\n  }\n\n  return global.classValidatorMetadataStorage;\n}\n"]},"metadata":{},"sourceType":"module"}